---
status: pending
parallelizable: true
blocked_by: []
---

<task_context>
<domain>frontend/ui/data-filtering</domain>
<type>implementation</type>
<scope>bug_fix</scope>
<complexity>medium</complexity>
<dependencies>api|state_management|data_filtering</dependencies>
<unblocks>none</unblocks>
</task_context>

# Tarefa 5.0: Corre√ß√£o do Filtro de Categorias Expense

## Vis√£o Geral

Corrigir o problema onde categorias criadas com tipo "expense" n√£o est√£o aparecendo corretamente na tela de transa√ß√µes. Isso envolve investigar e corrigir o filtro de categorias no formul√°rio de transa√ß√µes para garantir que todas as categorias do tipo apropriado sejam exibidas.

## Requisitos

1. Categorias "expense" devem aparecer ao criar/editar despesas
2. Categorias "income" devem aparecer ao criar/editar receitas
3. Filtro deve considerar categorias com tipo "both" (se aplic√°vel)
4. Categorias inativas n√£o devem aparecer
5. Ordena√ß√£o alfab√©tica das categorias no dropdown

## Subtarefas

- [ ] 5.1 Diagnosticar o problema
  - Verificar resposta da API /api/v1/categories
  - Confirmar que categorias expense existem no backend
  - Analisar filtro no TransactionForm
  - Identificar causa raiz

- [ ] 5.2 Analisar l√≥gica de filtro atual
  - Arquivo: `/frontend/src/components/transactions/TransactionForm.tsx`
  - Linhas 154-161: l√≥gica de filtro de categorias
  - Verificar condi√ß√µes de filtro
  - Identificar se bug √© no filtro ou nos dados

- [ ] 5.3 Verificar API de categorias
  - Endpoint: GET /api/v1/categories
  - Confirmar que retorna categoria_type corretamente
  - Verificar se filtro por tipo funciona
  - Testar query params se necess√°rio

- [ ] 5.4 Verificar tipos TypeScript
  - Arquivo: `/frontend/src/types/category.ts`
  - Confirmar que CategoryType inclui 'expense'
  - Verificar interface Category
  - Validar consist√™ncia com backend

- [ ] 5.5 Corrigir filtro no TransactionForm
  - Implementar l√≥gica correta de filtro
  - Considerar categorias tipo "both"
  - Adicionar console.log para debug
  - Validar l√≥gica com diferentes cen√°rios

- [ ] 5.6 Testar corre√ß√£o
  - Criar categorias de teste (expense, income)
  - Tentar criar despesa
  - Verificar se categorias expense aparecem
  - Tentar criar receita
  - Verificar se categorias income aparecem

- [ ] 5.7 Validar casos edge
  - Categorias sem tipo definido
  - Categorias inativas
  - Categorias tipo "both"
  - Lista vazia de categorias

## Sequenciamento

- Bloqueado por: Nenhuma tarefa
- Desbloqueia: Nenhuma tarefa
- Paraleliz√°vel: Sim (pode executar junto com outras tarefas)

## Detalhes de Implementa√ß√£o

### An√°lise do C√≥digo Atual

Em `/frontend/src/components/transactions/TransactionForm.tsx` (linhas 154-161):

```typescript
<Select
  label="Categoria"
  {...register('category_id')}
  error={errors.category_id?.message}
  options={[
    { value: '', label: 'Selecione uma categoria' },
    ...(categories?.filter(cat =>
      cat.category_type === transactionType ||
      cat.category_type === 'both'
    ).map(cat => ({
      value: cat.id.toString(),
      label: cat.name
    })) || [])
  ]}
/>
```

### Poss√≠veis Problemas

1. **Problema no Backend**
   - Categorias n√£o est√£o sendo retornadas pela API
   - Campo category_type n√£o est√° sendo serializado
   - Filtro no backend est√° errado

2. **Problema no Frontend**
   - Filtro usa compara√ß√£o estrita mas dados v√™m diferentes
   - Tipo "expense" escrito diferente (ex: "Expense", "EXPENSE")
   - Categorias n√£o est√£o chegando no componente

3. **Problema de Tipos**
   - TypeScript pode estar esperando tipo diferente
   - Inconsist√™ncia entre tipo definido e dados reais

### Diagn√≥stico Passo a Passo

#### Passo 1: Verificar Dados da API

```typescript
// Adicionar no TransactionForm (tempor√°rio para debug)
useEffect(() => {
  console.log('=== DEBUG CATEGORIAS ===')
  console.log('Total de categorias:', categories?.length)
  console.log('Categorias completas:', JSON.stringify(categories, null, 2))

  if (categories) {
    const expenseCategories = categories.filter(cat => cat.category_type === 'expense')
    const incomeCategories = categories.filter(cat => cat.category_type === 'income')
    const bothCategories = categories.filter(cat => cat.category_type === 'both')

    console.log('Categorias expense:', expenseCategories.length, expenseCategories)
    console.log('Categorias income:', incomeCategories.length, incomeCategories)
    console.log('Categorias both:', bothCategories.length, bothCategories)
  }
  console.log('Tipo de transa√ß√£o atual:', transactionType)
  console.log('========================')
}, [categories, transactionType])
```

#### Passo 2: Verificar Backend

```ruby
# Verificar TransactionController - m√©todo index ou filter_options
# Garantir que categorias s√£o inclu√≠das

# Verificar CategorySerializer (se existir)
class CategorySerializer
  def as_json
    {
      id: @category.id,
      name: @category.name,
      icon: @category.icon,
      color: @category.color,
      category_type: @category.category_type,  # ‚Üê Importante
      is_active: @category.is_active
    }
  end
end
```

#### Passo 3: Testar API Manualmente

```bash
# Testar endpoint de categorias
curl -H "Authorization: Bearer YOUR_TOKEN" \
  http://localhost:3001/api/v1/categories

# Verificar resposta:
# - Tem categorias?
# - Tem campo category_type?
# - Valores s√£o "income", "expense", "both"?
```

### Solu√ß√£o - Filtro Robusto

Implementar filtro mais robusto que lida com diferentes casos:

```typescript
// /frontend/src/components/transactions/TransactionForm.tsx

// Fun√ß√£o helper para filtrar categorias
const getFilteredCategories = () => {
  if (!categories || !Array.isArray(categories)) {
    console.warn('Categorias n√£o dispon√≠veis ou formato inv√°lido')
    return []
  }

  // Para transfer√™ncias, n√£o mostrar categorias
  if (transactionType === 'transfer') {
    return []
  }

  // Filtrar categorias ativas e do tipo correto
  const filtered = categories.filter(cat => {
    // Verificar se categoria est√° ativa
    if (cat.is_active === false) {
      return false
    }

    // Verificar tipo
    const categoryType = cat.category_type?.toLowerCase()
    const currentType = transactionType?.toLowerCase()

    // Incluir se:
    // 1. Tipo da categoria corresponde ao tipo da transa√ß√£o
    // 2. Categoria √© do tipo "both"
    return categoryType === currentType || categoryType === 'both'
  })

  // Ordenar alfabeticamente
  return filtered.sort((a, b) => a.name.localeCompare(b.name, 'pt-BR'))
}

// Usar no Select
<Select
  label="Categoria"
  {...register('category_id')}
  error={errors.category_id?.message}
  options={[
    { value: '', label: 'Selecione uma categoria' },
    ...getFilteredCategories().map(cat => ({
      value: cat.id.toString(),
      label: cat.name
    }))
  ]}
/>
```

### Solu√ß√£o Alternativa - Normaliza√ß√£o de Dados

Se o problema for inconsist√™ncia de dados:

```typescript
// Hook personalizado para normalizar categorias
const useNormalizedCategories = () => {
  const { data: categoryResponse } = useCategories()

  const categories = useMemo(() => {
    const raw = Array.isArray(categoryResponse?.data)
      ? categoryResponse.data
      : []

    // Normalizar dados
    return raw.map(cat => ({
      ...cat,
      category_type: cat.category_type?.toLowerCase() as 'income' | 'expense' | 'both',
      is_active: cat.is_active !== false
    }))
  }, [categoryResponse])

  return categories
}

// Usar no componente
const categories = useNormalizedCategories()
```

### Solu√ß√£o Backend - Garantir Dados Corretos

Se problema estiver no backend:

```ruby
# /backend/app/controllers/api/v1/categories_controller.rb

def index
  @categories = Category.available_for_user(current_user)
                        .where(is_active: true)  # Apenas ativas
                        .order(:category_type, :name)

  # Filter by type if provided
  if params[:category_type].present?
    @categories = @categories.where(category_type: params[:category_type])
  end

  paginate @categories
end

# Adicionar m√©todo no modelo se n√£o existir
# /backend/app/models/category.rb
class Category < ApplicationRecord
  enum category_type: { income: 0, expense: 1, both: 2 }

  scope :available_for_user, ->(user) {
    where('user_id = ? OR user_id IS NULL', user.id)
  }

  scope :active, -> { where(is_active: true) }
  scope :for_type, ->(type) { where(category_type: type) }
end
```

## Cen√°rios de Teste

### Teste 1: Categoria Expense em Despesa
1. Criar categoria tipo "expense" chamada "Alimenta√ß√£o"
2. Criar nova transa√ß√£o tipo "despesa"
3. Abrir dropdown de categorias
4. Verificar que "Alimenta√ß√£o" aparece na lista
5. Selecionar e salvar
6. Confirmar que transa√ß√£o foi salva com categoria

### Teste 2: Categoria Income em Receita
1. Criar categoria tipo "income" chamada "Sal√°rio"
2. Criar nova transa√ß√£o tipo "receita"
3. Abrir dropdown de categorias
4. Verificar que "Sal√°rio" aparece na lista
5. Confirmar que categorias expense N√ÉO aparecem

### Teste 3: Categoria Both
1. Criar categoria tipo "both" chamada "Ajustes"
2. Criar despesa
3. Verificar que "Ajustes" aparece
4. Criar receita
5. Verificar que "Ajustes" aparece novamente

### Teste 4: Categorias Inativas
1. Criar categoria expense ativa: "Transporte"
2. Desativar categoria
3. Criar nova despesa
4. Verificar que "Transporte" N√ÉO aparece
5. Editar transa√ß√£o existente que usa "Transporte"
6. Categoria deve ainda aparecer na transa√ß√£o existente

### Teste 5: Lista Vazia
1. Desativar todas as categorias
2. Criar nova transa√ß√£o
3. Verificar que dropdown mostra apenas "Selecione uma categoria"
4. Interface n√£o deve quebrar

### Teste 6: Transfer√™ncia
1. Criar nova transfer√™ncia
2. Verificar que campo de categoria n√£o aparece ou est√° desabilitado
3. Transfer√™ncias n√£o devem ter categorias

### Teste 7: Ordena√ß√£o
1. Criar categorias: "Zebra", "Alimenta√ß√£o", "Moradia"
2. Abrir dropdown
3. Verificar ordem alfab√©tica: Alimenta√ß√£o, Moradia, Zebra

### Teste 8: Edi√ß√£o de Transa√ß√£o
1. Criar despesa com categoria expense
2. Editar transa√ß√£o
3. Alterar tipo para receita
4. Verificar que dropdown atualiza para categorias income
5. Categoria anterior n√£o deve estar selecionada

## Crit√©rios de Sucesso

- [ ] Categorias "expense" aparecem ao criar despesas
- [ ] Categorias "income" aparecem ao criar receitas
- [ ] Categorias "both" aparecem para ambos os tipos
- [ ] Categorias inativas n√£o aparecem
- [ ] Lista ordenada alfabeticamente
- [ ] Filtro atualiza ao mudar tipo de transa√ß√£o
- [ ] Transfer√™ncias n√£o mostram categorias
- [ ] Sem erros no console
- [ ] Performance adequada (n√£o trava ao abrir dropdown)
- [ ] Funciona ao editar transa√ß√£o existente

## Arquivos a Modificar

### Frontend
- `/frontend/src/components/transactions/TransactionForm.tsx` (principal)
- `/frontend/src/hooks/useCategories.ts` (se necess√°rio normalizar dados)
- `/frontend/src/types/category.ts` (se necess√°rio ajustar tipos)

### Backend (se necess√°rio)
- `/backend/app/controllers/api/v1/categories_controller.rb`
- `/backend/app/serializers/category_serializer.rb` (se existir)
- `/backend/app/models/category.rb` (verificar enum e scopes)

## Impacto em Outros Componentes

Verificar se filtro de categorias √© usado em outros lugares:
- [ ] Dashboard - pode ter gr√°ficos por categoria
- [ ] Relat√≥rios - pode filtrar por categoria
- [ ] CategoryStatistics - deve considerar mesmo filtro

## Debug e Logging

Adicionar logs tempor√°rios para diagnosticar:

```typescript
// No TransactionForm
console.group('üîç Debug Categorias')
console.log('Tipo de transa√ß√£o:', transactionType)
console.log('Total de categorias:', categories?.length)
console.log('Categorias filtradas:', getFilteredCategories().length)
console.table(getFilteredCategories().map(c => ({
  id: c.id,
  nome: c.name,
  tipo: c.category_type,
  ativa: c.is_active
})))
console.groupEnd()
```

## Valida√ß√£o Final

### Checklist Funcional
- [ ] Expense ‚Üí mostra expenses e both ‚úì
- [ ] Income ‚Üí mostra incomes e both ‚úì
- [ ] Transfer ‚Üí n√£o mostra categorias ‚úì
- [ ] Inativas ‚Üí n√£o aparecem ‚úì
- [ ] Ordena√ß√£o alfab√©tica ‚úì
- [ ] Performance ok ‚úì

### Checklist T√©cnico
- [ ] C√≥digo limpo e comentado
- [ ] Sem console.logs no c√≥digo final
- [ ] TypeScript sem erros
- [ ] Sem warnings
- [ ] Testes manuais passando

### Checklist de UX
- [ ] Dropdown abre suavemente
- [ ] Categorias f√°ceis de ler
- [ ] Mensagem clara se lista vazia
- [ ] Comportamento intuitivo
- [ ] Mobile friendly

## Tratamento de Erros

```typescript
// Adicionar tratamento para caso API falhe
const getCategoryOptions = () => {
  try {
    if (!categories || !Array.isArray(categories)) {
      return [{ value: '', label: 'Nenhuma categoria dispon√≠vel' }]
    }

    const filtered = getFilteredCategories()

    if (filtered.length === 0) {
      return [{
        value: '',
        label: transactionType === 'transfer'
          ? 'Transfer√™ncias n√£o usam categorias'
          : 'Nenhuma categoria dispon√≠vel para este tipo'
      }]
    }

    return [
      { value: '', label: 'Selecione uma categoria' },
      ...filtered.map(cat => ({
        value: cat.id.toString(),
        label: cat.name
      }))
    ]
  } catch (error) {
    console.error('Erro ao processar categorias:', error)
    return [{ value: '', label: 'Erro ao carregar categorias' }]
  }
}
```

## Documenta√ß√£o

Ap√≥s corre√ß√£o, documentar:
- Causa raiz do problema
- Solu√ß√£o implementada
- Testes realizados
- Pontos de aten√ß√£o para futuro

## Rollback Plan

Se corre√ß√£o causar problemas:
1. Reverter mudan√ßas no TransactionForm
2. Verificar se API est√° funcionando
3. Investigar mais profundamente backend
4. Considerar abordagem alternativa

## Tempo Estimado

1-2 horas

## Pr√≥ximos Passos

Ap√≥s completar esta tarefa:
- Sistema de categorias funcionando completamente
- Usu√°rios podem criar transa√ß√µes com categorias corretas
- Experi√™ncia de cria√ß√£o de transa√ß√£o melhorada
- Base s√≥lida para features futuras de categoriza√ß√£o

## Notas Adicionais

- Este √© um bug cr√≠tico que afeta usabilidade
- Pode impactar relat√≥rios se categorias n√£o forem salvas
- Importante testar com dados reais de produ√ß√£o
- Considerar adicionar testes automatizados ap√≥s corre√ß√£o
- Avaliar criar endpoint espec√≠fico para categorias por tipo
